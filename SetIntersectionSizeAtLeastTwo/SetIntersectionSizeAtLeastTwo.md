# Set Intersection Size At Least Two
有技巧的貪心，謂之算法。

## 題目介紹及構想
- input
  - intervals(vector<vector< int>>)
    - a intervals between a and b, include a and b. a < b
- process
  - find a set. this set include the least two value in every intervals.
- output
  - result(int)
    - the size of set.

## 開始
想到Greedy，最先想到的就是當下最好就是全部最好，但要如何讓這成立呢，一定在於順序。首先不排序的情況下鐵定會出事的，畢竟不知道是要用哪兩個變數放入set中。

而這有兩個變數情況下，會有八種排序狀態，分別因為有ab及先後判跟遞增減的關係。總之我先照我的思考邏輯走

首先想到當然是a先判啦。至於方法跟之前看過的一些想法雷同，就是遞增再遞增。

- a先判 a遞增，b遞增
  - 想法
    - 這樣可行嗎?我們從第一個開始，因為其他都頭都>=它的，所以選取他的尾端似乎可行?
  - 結論
    - 否定，舉例`[1,10],[1,11],[2,3],[8,9]`，這情況下，選取`[1,10]`尾端似乎自尋死路，但要怎麼找到中間呢?

看來似乎不可行?那原因呢，就是在於最重要的不是a在頭，我們要被查看range的似乎是尾端(比較接近群體)，那是不是我們要先判b。所以換個思考方向。

- b先判 b遞增，a遞增
  - 想法
    - 這樣看起來一樣，但是上述範例會變成`[2,3],[8,9],[1,10],[1,11]`，恩，很棒，`[2,3]`是一個群體，`[8,9]`是一格群體，`[1,10]`跟`[1,11]`包含它們，所以沒事。
  - 結論
    - 找找看反例吧。`[1,4],[4,10],[9,10],[10,11]`這狀態，如果先跑`[4,10]`了，`[9,10]`理應就會剩一個存值，可是沒有去紀錄變數到底是用哪個我們就沒法發現`[10,11]`被占去的兩個位置其實都是10這個數。看來這也是失敗了。
    
開始尋找問題根本，我們似乎先排尾端是正確的，但是頭端的順序是不是應該要從短的先判，因為短的區間可以被長的包含，但長的不能包含短的。

- b先判 b遞增，a遞減
  - 想法
    - 修正了上述想法，我們因為先判b(尾端)，所以我們可以用假設所有頭端小於我的都被我包含。
    - 改成a遞減，所以我可以判斷掉尾端跟我相同的所有可能。(尾端比我大的已經被包含在其一了)
  - 結論
    - 至少反面教材不好找，直接問問submit吧。

code想法如下

```C++ =
cmp is return (a[1]!=b[1]) ? a[1] < b[1] : a[0] > b[0];// 尾端不相同就回傳尾端大的，反之，回傳頭端小的
    int intersectionSizeTwo(vector<vector<int>>& intervals) {
        int number = 0;
        sort(intervals,cmp);
        vector<int> unInside;
        
        set unInside is size N(N is intervals.size()), and init every value is 2
        // 表示一開始大家都沒有放入的點有兩個
        
        for(int i = 0 ~ N) {
            end = intervals[i][1]; //尾端
            n = unInside[i];//要放入幾個點
            for(p = end~end-n) {//從尾巴開始放入n個值 e.g. end = 10, n = 2 放入10,9. end = 10, n = 1 放入10
                for(int j = i ~N) {
                    if(unInside[j] > 0 && intervals[j][0] <= p) {
                        unInside[j]--;//如果頭小於的p的所有範圍，都保正被放入一個值。
                    }
                }
                number++;//放入一個值
            }
        }
        
        return number;//回傳總放入值
    }
```

其實也想了很久，但是確保沒有問題後，一次就AC了。

## 參考答案
其實弄到最後，我發現答案似乎跟參考答案一樣，就是去確認每個範圍是不是在裡面，可是它是用從尾端開始的方式，似乎比較簡單去想。但邏輯都是一樣的。

可是後來我發現，其實這種方式比較接近DP，去儲存狀態防止重複動作(不過這裡重複就答案錯了)的想法去處理。我在其他人code裡發現了真正的Greedy法。

它不需要判斷排序方式，只需要排序頭端而已，它把所有可能用ifelse陳述了一次令我完全發現紀錄所有事多此一舉，只要判斷兩個最前端的放入值，就可以判斷~~全世界~~我這個區間有沒有兩個值在裡面了。

陳述句大概是如下。(它是從尾端開始，就是頭端最大的範圍)
```C++ = 
P 是放入的最小值
PP 是放入的第二小值
if(tail >= PP) 表示我整段都包含P和PP，因為我的頭端一定小於等於P
else if(tail>=P){ 表示我們只包含一個值
    if(head < P){
        PP = P
        P = head
        將此段頭端放入set
    } else{只可能發生等於，因為大於被我們sort排除
        PP = P+1
        因為我們只包含P所以要多值，但是多的值只能是P+1(因為不存在比P小的值)
    }

}else 更新P和PP為現在頭兩個值//因為該段完全不再裡面。
```
如此簡單一層迴圈，不用在跑一層去一一改變其值，多麼精減的想法，好吧我沒想到。

## 感想
Greedy要Greedy的漂亮是有學問的，差一點的人呢用了更多空間但也花了更多時間。