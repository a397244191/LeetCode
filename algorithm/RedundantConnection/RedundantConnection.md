# Redundant Connection
久久動一次，想法都會變很天真。
## 題目介紹及構思
- input
  - edges(vector<vector< int>>)
    - all edges of a undirected graph
- process
  - find a edge, and remove it. the graph will become a tree.
- output
  - vector< int>
    - a edge we need to remove

很簡單的union find問題。

## 開始
簡單的判斷兩端點是否在同一個集團即可。

### union find
這是為了判斷兩點是否在同一個集合的方法。用一段陣列紀錄它的上一的點(根結點就是自己)。每次判斷時就往上找出各自的根結點。如果相同則表示它們在同一個集合中，而不相同，若要合併就將兩者其一的根結點指向另一個根結點即可。而這裡會出現兩個優化方式。

#### 層數
因為這結構其實就是個tree。而從tree最底層往上到根最重要的就是深度了。而因為根結點要連接到另一個根結點，會導致連接過去的那邊最大層數加1。而如果能每次都讓層數高的那邊被結合(不用連接到另一個根)，就可以減少層數增加的問題。因為較矮的連接過去，層數也不會超過較高的，而整顆數的層數就可以維持。

#### 路徑壓縮
因為每次find時，都要爬過各個上層才能到root，如果這時我要不斷對一個底層的結點查詢時，就會導致做了一多不必要的事情，這時候在查詢過程中，利用recursive的回傳特性，將根結點更新到它的查詢點上，就能夠節省第二次後的查詢時間。

### 做法
而這裡我並沒有去紀錄層數 ~~(我如此相信測資X)~~ ，只用了壓縮路徑的方式。

### WA
我不知道是不是我太頹廢了，一開始竟然好傻好天真的想說它們本來就會連在一起，只要判斷有沒有在裡面就好的想法。吃了一次WA。不過發現我的天真後改成union find寫法就沒事了。

## 參考答案
這裡比較有趣的也是我一開始有想到的DFS。只要我用DFS不要走回頭路，如果繞在一起就表示我找到了一個edge是多餘的了。

## 感想
哎呀，剛好挑到一題十分經典的題型。