# Wildcard Matching
更新一天又繼續忙，git顯示一定很灰暗QQ
## 題目介紹及構思
- input
  - s(string)
    - a string include a to z
  - p(string)
    - include a to z and '?', '*'
- process
  - '*' can replace any substring, include empty
  - '?' can replace any one char
- output
  - true
    - if s = p

沒意外DP解法簡單，跟上次某題很像。對解過的人來說不是hard的難度。

## 開始
總之依照之前印象想DP吧~~(兩周空窗)~~，因為這次'*'不用管前面接什麼應該更簡單。所以就一一比對，如果相同(或是'?')就等於兩字串各加一個字元，而如果'*'則可以表示三種模式，s多一個字元、p多一個字元及雙方都多一個字元。所以DP會如下。

```C++ =
if('*'){
    dp[i][j] = dp[i-1][j] || dp[i][j-1] || dp[i-1][j-1];
} else if(same || '?')
{
    dp[i][j] = dp[i-1][j-1];
} else dp[i][j] = false;
```
這次彼此不同沒有參考點，直接false(之前那次因為*可以repeate 0 times，所以要注意)。

很簡單的測了幾個測資，發現'*'開頭時會有問題，多加了當'*'時`dp[i][0] = dp[i-1][0]`(因為j - 1 = -1 都不用看)就解決了。

一次AC，可是時間很慢，發現有更好的greedy解。

## 參考答案
主要驚豔的是greedy解，雖然我知道有tag有解法，可是畢竟偷懶太久~~(其實也有繼續磨練code啦，另一方面的)~~所以還是以簡單的想法先下手。

想法很簡單，先根據s的去跑，當遇到跟p一樣(包含'?')就同時前進，而當遇到'*'則去記錄s跟p的位置讓p往下走，如果不同表示'*'需要增加代替字串，直到s跑完，而當s跑完，就看p到跑完前有沒有遇到非'*'，如果有則表示不同，而都沒事就是成功。

實際根據DP表去確認後，greedy的wrost case就是把DP表幾乎走滿，但大多時候都比跑整個DP少，所以快非常多(20ms跟180ms的差距)而且沒有用太多memory，在space上也很少，實在十分厲害。

雖然今天不想動腦，但這greedy的解法簡單到可以輕易明白，令我深感佩服。

## 感想
幾乎兩周只在中間打過一題，我還以為即使跟之前類似的題目，我也會因為修練不足而爆炸好多次，不過看來是我多心的，完每解決問題。
