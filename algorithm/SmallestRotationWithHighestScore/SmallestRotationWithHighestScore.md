# Smallest Rotation with Highest Score
知識累積不是無用的，是你不知道在哪會有用。

## 題目介紹及構思
- input
  - A(vector< int>)
    - a list number , each number is in 0 ~ A.length
- process
  - rotate A, find the max point(get point only in `R[i]<=i`, R is rotated vector A )
- output
  - R(int)
    - rotate A R times, we can calculate the max point

應該用紀錄方式就能解決吧?我是這麼想的。

## 開始
A的長度夠大，<a href="https://www.codecogs.com/eqnedit.php?latex=O(N^2)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?O(N^2)" title="O(N^2)" /></a>暴力絕對會失敗，所以要想辦法 ~~(廢話)~~ 。

### 區間跟填空
我可以簡單的計算出旋轉b~e個位置這區間可以獲得點數，也知道如果統計下來就能直接掃紀錄陣列找到答案。但是這樣其實還是無法壓低時間複雜。

```C++ = 
int bestRotation(vector<int>& A) {
    len = A.size();
    rotate(A.size(),0);
    for(int i = 0 ; i < len ; i++){
        beginR = i + 1;
        endR = beginR + ((len - 1) - A[i]);
        for(j = beginR ~ endR){
            if(A[i] <= (i-j+len)%len) rotate[j%len]++;
        }
    } 
    maxR = 0, maxC = 0
        
    loop : find the max number
        
    return maxR;
}
```
不過我不死心的丟了上去，結果是可想而知的TLE。

### 偷看開竅
因為題目想法太簡單了，反而不知道別的方法或是修改才能減少時間複雜度。而右所以跑去偷看解答 ~~(這樣可以嗎?)~~ ，然後還沒看敘述就看到一個++一個--做完紀錄的事情時，突然開竅似的立馬關掉。突然想大喊，這不是乘法器嗎!!!


> 乘法技巧
> 這裡岔開話題補充一個bit的乘法技巧。
> 當兩數字A跟B相乘時(A bit數 > B bit數)，在2進位下，整個乘法需要計算N(N < B bit數)次加法，而當B的值中1很多時，就會導致N變成很大。所以用了一個方式減少1的數目，想法如下：
> 
> 11111 = 100000 - 1
> 
> 這樣就能對一連串的1縮減到2次計算解決。更詳細的請見Booth Recoding，就不多贅述了。


藉由這個乘法方法，因為我們的b ~ e保證是連續的(頭尾可相連)，所以也可以變成兩個1的變化，原本需要(e-b)次的迴圈(<a href="https://www.codecogs.com/eqnedit.php?latex=O(N)" target="_blank"><img src="https://latex.codecogs.com/gif.latex?O(N)" title="O(N)" /></a>)就能縮減成2(const time)了。

```C++ = 
for(int i = 0 ; i < len ; i++){
    beginR = i + 1;// origin b
    endR = beginR + ((len - 1) - A[i]) + 1; // endR is (origin e + 1)
    rotate[beginR] --;
    rotate[endR]++;
```
這裡最開始有個想法是讓`A[0] == 0`，也就是`beginR%len == endR%len`的情況下有特殊處理。另`rotate[0]--`而沒有++的地方。因為認為特別的點，但後來又認為其實就是回到`rotate[0]`再加上去，所以改成了`if(beginR != endR) do something`，最後發現其實+1-1後就是不做事情阿，幹嘛多加判斷惹麻煩，所以上面是最精簡的版本。

#### 修改後的查詢
這裡查詢方式很簡單，就是找到`Sum(rotate[0]~rotate[N])`最小值的N。至於為何是這樣呢?我們可以拆回去-1+1的地方開始思考。

遇到-1表示之後直到遇到+1前都是對該數字可以得分的地方，所以推廣出只要累積越多負的就表示我們有越多可以得分的點存在。所以最低點就是答案。

之後就因為沒有陷阱的AC了，至於後來開竅到完全理解的部分就是在參考答案裡(因位會逐漸推導到參考答案的解法)。

## 參考答案
總之先不提參考答案內容，來讓我的最終想法推導出參考答案吧。

### 原因
因為為何是最小值為答案這件事十分不合理。但答案卻對了。

### 想法加深
先拆解成一個個的-1跟+1吧。當這個數遇到-1表示開始可以得點，而遇到+1則是結束得點，所以如果反過來是不是就更合最多得點獲勝的想法呢?這是沒錯的。所以先讓+1跟-1顛倒過來，這樣最後查詢就變成找最大值了。

### 加一直到減一
這裡加一直到減一中間會一直維持著+1的狀態，表示該點持續被紀錄得點，而直到遇上-1就是該點無法得點，所以之後的+1就被-1取消得點了。

#### 剛好轉過來
因為它是頭尾相連的，那如果先遇上-1呢?因為是相對性的，你多了一點其他沒得的就少了一點，所以表示遇上-1時該位置無法得點而減少，直到遇上+1又開始得點。

### 相對的，所以...
其實到這邊我就看出來了，把`A[0] == 1`的情況只有-1拿掉，改為+1-1。其實這就是相對狀況，而跟誰相對呢，在考慮幾筆測資後發現是跟K = -1(因為沒有負的所以是K = len - 1)。為何不是0呢?發現的原因有兩點。

1. 最後統計是0。
2. K = 0,也被視為一種變化狀態。

經過兩點推算，K = len - 1時，總計值保證是0，所以可以循換。而這個陣列其實是對於某個狀態X做一次變化(`+rotate[n]`)而變成變化後狀態(`rotate[n]`)，所以其實起點是任何狀態都可以的(因為每個都有+1-1加完全部最後都是歸0)，只是因為我們是從K = 0開始，所以原始狀態是K = len - 1。

### 最大得點獲得
所以根據上面發現得點是相對的後，只要將0到最大值的總計加上K = len - 1的得點，就會是最大得點值。

### 參考做法
最後再回頭看參考做法一整個海闊天空的感覺，它只是述說成去取得無法得點區間的想法而已。

## 感想
有時候就是死腦筋不知變通，沒有外力打醒前都不會知道有更好的方法。而也突然對於問題可以跟自己莫名區塊的知識連結，而感到美妙的神秘感?
