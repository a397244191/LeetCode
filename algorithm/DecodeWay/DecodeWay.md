# Decode Ways
不知道腦袋還沒醒來還是怎樣，屢試不爽。
## 題目介紹及構想
- input
  - s(string)
    - not empty, and only digit
- process
  - decode 1 ~ 26 to A ~ Z
- output
  - number(int)
    - the number of all solutions of decoding string.

我以為很簡單的想法是對的，可是被0搞暈了。

## 開始
首先我很簡單的想到兩個儲存。

1. 單獨成立
2. 有前面結合

實際上應該也就這兩個。所以最初設計成這樣。

```C++ =
number[2] = {1,1}

for(i = 1 ~n){
    number[0] = number[0] + ((s[i-1,i] is 10~26) ?number[1]:0)
    number[1] = number[0];
}
```
想法就這樣，前一次被直接繳出的是`number[0]`，而前一次保留是`number[1]`，只要保留後可以合成就會加入`number[0]`，而不能則是繼續直接輸出，而`number[1]`則是上次輸出後保留這次結果的狀況。

可是出現了0阻撓。

### 0的出現
一開始出現"0"以為是可以例外處理，可是又出現了"00"，我以為是要無視0，但其實不然。

### f("001") = 0
看到這筆測資才恍然大悟，出現0的情況都是錯誤input直接output 0，所以又修改一番。

### 本身邏輯障礙
不知道今天是怎樣，腦袋一直不靈光的想不出好測資 ~~(牽拖說詞:說不定是因為假日，或是手邊沒有紙可以寫，或是怎樣...)~~ 。搞得我有點障礙，這次收到的是"110"的測資，我把它算成前面"11"可以拆開所以出錯了。

### 砍掉重來
出去走走幾分鐘，回來再看看題目後，決定舊方法是有問題的。

重新想一下後，決定把把現在保留跟不保留狀況改成現在被單獨decode跟組合decode。

```C++
    int numDecodings(string s) {
        int number[2] = {1,0};
        if(s[0] == '0') return 0;
        for(int i = 1 ~ n) {
            next[0] = (s[i] == '0') ? 0 : (number[0] + number[1]);
            next[1] = s[i-1,i] in 10~26 ? number[0] : 0;
            number = next;
        }
        return number[0] + number[1];
    }
```

把所有關係想清楚後，這樣的解法比上面的方法減少了一些處理及判斷(或是說包含了)。

### 想法轉變點
第一種方法沒有不好，只是因為把所有結論塞在`number[0]`裡面導致一堆問題需要判斷。換成第二種後，就是讓現在狀態結束儲存在兩個值裡面，可以更清楚的分辨狀態類別而不會導致混在一起要增加或不增加都出現問題。

而為何一開始就想用2個儲存解決問題的主要原因在於這次問題跟之前遇過的問題十分相像，每增加一個值會有兩種狀態這種模式，所以認為可以這樣解決。

## 參考答案
而這次沒有解答，然後也看了一下DP解，其實跟我想法相同，畢竟這次DP不牽涉更前面的DP值，所以不需要特別記錄下來，如果是前一種方法可能全記錄下來才有可能有解。

## 感想
今天莫名的有點卡問題，搞不清楚input格式的想法只好try and error。最後弄懂0的出現意義後才發現我一開始的code就是個不夠好的方法。