# 01 Matrix
哎呀，又有一陣子放置了呢 ~~(一直說這個不煩嗎?)~~
## 題目介紹及構思
- input
  - matrix(vector<vector< int>>)
    - only 1 or 0 matrix
- process
  - find the dist the cell and 0
- output
  - vector<vector< int>>
    - the dist of all cell

一開始想太多了，最後有想到方法。
  
## 開始
其實這題應該很簡單的從0擴散的BFS就行了 ~~(前兩次submit不知道在想什麼)~~ 。弄得現在想寫解析反而想法太簡單沒法下手。

### BFS特性
其實做法很簡單，就是將所有0塞進queue中，然後一個個拿出來處理，因為它會預先處理好所有數字小的部分，所以不會導致重複計算同一個cell的時候。

### 反省
因為最終解法的想法太簡單了，所以來回顧一下一開始兩個複雜又沒法解決的想法吧。

#### DFS?
最初的想法是用DFS跌代，嘗試在回頭時更新數值，最後在submit的時候戳出了當值無法確認時的問題而失敗了。

#### 一個個BFS
很好笑的，我竟然最開始是把BFS寫在掃陣列的loop中，導致每次queue都只有一個0當起點的狀況，而且在看到全塞進去時還不知道我的問題。最大的問題主要就是因為沒有將所有0先判斷，此時多個0掃到同一個區域時就會掃過那區域的總量乘上周圍0的數量的次數。有趣的是，這方法勉強壓線AC了。只事後來再修正成最新版本。

總之WA一次跟差點TLE一次後，有個滿意的AC了。

## 參考答案
最終版本的方式其實就是解答第一個AC的解法，所以也不多談。主要是看一個我有想到但沒想完的方法。

### DP
其實這題因為要全部都探訪回傳，某意義上都是DP，不過大多經典的DP都應該要有一個特點，就是可以直接掃陣列結束問題，所以BFS方法不會第一個歸類在這。

其實一開始我有想到一半，但後來因為擔心左上角(起點)會是1而失敗。結果解答告訴我真正的方法就是，倒回來再掃一次。方法很簡單，除了0為0外就是跟左跟上三者比較一次，找到最小值便為答案，而左上掃過去找不到的點，就從右下掃回來即可找到。這樣來回一次，時間複雜度跟BFS一樣沒有太大問題。

## 感想
怎麼說呢，果然技巧生疏了，明明方法最後我有想到也很簡單，卻是不斷失敗中的結果。果然缺乏磨練是不行的。