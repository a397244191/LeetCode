# Backspace String Compare
趁一點點時光寫個簡單題目，不然斷三天可不太好 ~~(如果天天回來都要寫，一整天頭腦會燒掉的)~~ 。

## 題目介紹及構思
- input
  - S(string)
  - T(string)
- process
  - check S and T are the same. '#' is backspace
- output
  - bool
    - if same return true

簡單的比對字串，可是要求const space !?

## 開始
本來想說easy很簡單的，這題只要丟stack最後長一樣就好了。可是要求要const space就不太好說了。

### stack
總之先想想stack怎麼做吧，就是將它丟進去，當遇到#時pop一個，直到最後再一起檢查剩下的就好了。這樣linear space可以解決。

### 從後面?
既然stack放進去後最後是從後面檢查，那是不是我直接從後面來也可以呢?，這樣想的突然發現，因為從前面完全不知道我現在的字元是不是要被刪除的還是留下，所以都要保留。但從後面可以先看到會遇到的#，這樣只要刪完了還不是#就表示會被留下。

### 一個一個來
想到這裡，本來想一次兩個一起跑，可是這樣會有很多判斷要走。突然想到如果各自先跑到需要判斷再來呢?這靈機一動讓我決定這樣，先紀錄它被刪去的數量，直到發現這不能刪除(數量>1)時，就表示這字元被留下了，需要跟另一串比較。
```C++ =
while(n <=0 && p >= 0){
    if(last == '#') n--;
    else n++;
    p--;
    last = S[p];
}
if(sn > 0) last = S[++p];
```
出來後做的判斷是因為，如果我現在n 是 1，就是`S[p+1]`需要判斷，而為了之後判斷p值順利，所以先+1。而如果n < 0就表示一路delete到底了，字串是空的，就不管了。

### 判斷相同
兩個都做了上述事情後，會得到兩個重要資訊，p跟last，而分別是sp,tp跟slast,tlast。

```C++ =
if(sp < 0 && tp < 0) return true;
else if(sp < 0 || tp < 0) return false;
if(slast != tlast) return false;
else {
    sn--;
    tn--;
}
```
這裡做了兩部分檢察，如果兩個字串最後都是空的，就表示相同回傳true，如果只有一個空的，就是不相同。而如果兩個都還要繼續判斷的情況下，last卻不一致，就可以當做不相同。

### 維持p
最後因為要呼應前面的部分，所以我們的p要加回來，last也要變成下一個。所以做下面動作。
```C++ =
if(p >= 0) {
    p--;
    last = S[p>0 ? p:0];
}
```
稍微確保last不會炸掉後，將p--並將last設為`S[p]`，此時當p小於0時，last值就不重要了(因為不進迴圈)。

測試了一些狀況後，AC了。

## 參考答案
簡單題目，沒有超出我想像的特殊答案，就不多看了。

## 感想
即使題目再簡單，只要加點要求，還是需要動點腦才能沒問題的解決。
