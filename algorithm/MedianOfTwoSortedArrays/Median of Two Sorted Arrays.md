# Median of Two Sorted Arrays
雖然trial and error對解決問題很有效率，但不好好謹慎的submit大概會讓我的AC率狂掉QQ。

## 題目介紹及構思
- input
  - nums1(vector< int>)
    - a sort array
  - nums2(vector< int>)
    - a sort array
- process
  - find the median in those two array.
- output
  - double
    - median

binary search進化，感覺就是不容易的題目。
## 開始
總之該考慮要怎麼在一次binary search解決問題。(不只一次就有點不妙)

### 對半
因為兩個都是sort好的，所以可以知道中位數大於的數量，所以只要維持這數字似乎可行。

所以想法是，我對array1做binary search，並根據他的對應array2的位置的大小關係向左右移動。而這對應關係就是各自在array的位置相加會是比中位數小的總數目。

舉個例子 : array1{1,2,3,4,5,6,7}, array2{2,3,4,5,6,8,10}

這裡總數是14，中位數下的數是7個，array1.at(3) = 4，而對應的是array2.at(3) = 5，因為這樣4跟5最大值可以保證有7個數比它小。而根據4<5的結果，4需要繼續增加(下限靠近中位數)，而相對5就會減少(上限靠近中位數)。

### 長度
但後來發現，對應的數字出現不在範圍的怎麼辦?!看了半天，發現比較短的那邊無法完全配對比較長的，然後開始考慮長的多出來部分。

#### 不可能
因為是找中位數，所以不可能找到在長的那邊而沒有對應的問題，因為如果中位數search超出那個範圍，就不會是中位數了，因為那個對應位置的邊界，就是將短的一端全保證在長的同一邊才會發生，所以最多就是配對的部分。而為了讓配對後盡量不出現超出邊界~~(最後竟然還是出現了QQ)~~，所以絕對另search那邊維持是短的。

#### 保持短的
其實很簡單，就是用指標去指向兩陣列，就可以在不動到兩陣列的情況下維持短的被search(傳function也行)。

### search內容
其實就是一個很簡單的binary search，而真正難的就是在search完的結果要好好想清楚。

```C++ =
ltN = (n+m)/2;// less than number
while(l < r) {
    mid = (l + r) / 2
    if(n1[mid] < n2[ltN - mid - 1]) l = mid + 1;
    else if(n1[mid] > n2[ltN - mid - 1]) r = mid - 1;
    else return n1[l];
}
```

這裡有趣的是，如果數字相同，表示它們就是中位數。而其他狀況，就跟一般binary search一樣。

#### 邊界狀況
這在很後面才發現，不過就是遇到r在只有兩個數時，會變成-1的狀況，大概是因為之前binary search是表示要正好找到的關係吧，所以這次要保留l跟r時就會出現。
```C++ =
if(r < 0) r = 0;
if(l >= n) l = n - 1;
```
雖然沒遇到l的狀況，不過以防萬一，還是補一下。總之這樣就能保證不會邊界炸裂了。

### 誰是中位數
目前狀況是找到可能兩個或四個中位數後補，兩個是剛好l == r的情況。所以要找到真正的中位數~~(這是哪來的推理遊戲啦)~~

#### 4個數
先提提四個數，因為這裡沒有太多例外，因為r跟l都找的到，也有對應的值。
```C++ = 
mr = ltN - l - 1;
ml = ltN - r - 1;
ansArray = sort({n1[l],n1[r],n2[mr],n2[ml]});
```
4個值中，比較大的兩個已經確保數量足夠，而最大的被次大的插隊多了一個，所已答案會是這四個中間兩個(偶數情況)或是次大的那個(奇數情況)。而統整部分會跟2個組合。


#### 2個數
這想法其實很簡單~~(好啦，我就是這裡一直頭暈沒搞好啦!)~~，就是對這兩個中位數去查看有誰在它們中間。
```C++ = 
mpos = ltN - l - 1;
if(n1[l] > n2[mpos]
    if(mpos + 1 < m && n1[l] > n2[mpos + 1]) {
        ansList.push_back(n2[mpos + 1]);
    } else {
        ansList.push_back(n1[l]);
    }
    if(l > 0 && n1[l - 1] > n2[mpos]) {
        ansList.push_back(n1[l - 1];
    } else {
        ansList.push_back(n2[mpos]);
    }
} else if(n1[l] < n2[mpos]){
    if(mpos > 0 && n1[l] < n2[mpos - 1]) {
        ansList.push_back(n2[mpos - 1]);
    } else {
        ansList.push_back(n1[l]);
    }
    if(l + 1 < n && n1[l + 1] < n2[mpos]) {
        ansList.push_back(n1[l + 1]);
    } else {
        ansList.push_back(n2[mpos]);
    }
} else {
    return (double)(n1[l]);
}
```

寫得很多狀況，因為腦袋太亂還沒篩選。總而言之，因為我保證了兩個中位數，而接下來要用它們大小關係去確保沒有更接近的值。就是說對於兩者較小值的array n中是否存在比較小值大但卻小於較大值的，如果有就替換較大值。而另一邊也是這樣判斷是否有比較大值小卻大於較小值的。當然都只在另一個array找~~(就是在這被坑的)~~

所以最後會找的兩個值。

### 答案
經過上面整理，我可以找出最終是4個數字跟2個數字。而將它排列後，在4個數中就是次大為中位數(或是中位數上半部)，而2個數中，就是大的那個值是中位數(或是中位數上半部)。因此只要判斷奇偶就能知道中位數了。
```C++ =
mid = ansList.size()/2;
if(even) return (ansList[mid] + ansList[mid-1]) / 2;
else return ansList[mid];
```
基本上就是找陣列中位數~~(別再中位數啦!!!)~~

### 錯誤
一開始我想說，對於兩個數就將它塞進去，再跟後面方式一樣判斷，但才發現，我卻被3個值的狀況給騙了，因為我找到的是比最小值大，但並沒有比最大值小，卻放進來判斷，導致原是正確的最小值被擠出去的狀況，為了解決才將code改成8個判斷式而不是交由sort後的陣列判斷。

#### 其他
其他也沒什麼好說的，就是n1跟n2竟然搞錯了而炸掉。

## 參考答案
稍微看了一下，大致跟我的想法雷同，不過最終處理部分跟我差很多~~(嗚嗚，太精減了吧)~~，大致上就是保證mid + 1 跟 mid - 1是在 l跟r之間的binary search。

### 中間差別
大致就是在判斷移動前，先保證移動後不會l跟r交替。

### 最後處理
這裡很漂亮的解決法是，mid對應的另一個陣列位置pos來做判斷。對於mid-1跟pos-1的大小做比較，可以找到最大的左半部(而中位數包含在此，所以奇數個就回傳)。再讓mid跟pos做比較，會得到最小的右半部，這樣再讓兩個值平均就是中位數。

### 參考結論
只能說這處理方法很漂亮阿，值得參考的想法，也仔細看了它的解說。雖然有想到入門點，但後續處理部分弄得很混亂讓我一直出錯。這解答值得學習~~(廢話)~~

## 感想
終於解決問題後，只能說這想法太神奇了，感到佩服而已。